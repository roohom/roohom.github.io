

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>JavaSE_Day08 &mdash; roohom&#39;s notes 0.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="Java OOP防脱发指南" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB.html" />
    <link rel="prev" title="生产者消费者模型问题" href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> roohom's notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0904%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html">模拟面试题整理</a></li>
<li class="toctree-l1"><a class="reference internal" href="1008%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86.html">实时存储NoSQL模拟面试</a></li>
<li class="toctree-l1"><a class="reference internal" href="Annotation.html">元注解</a></li>
<li class="toctree-l1"><a class="reference internal" href="Annotation.html#id2">注解解析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Bigdata%E9%98%B2%E6%87%B5%E9%80%BC%E6%8C%87%E5%8D%97.html">Bigdata Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="Collection.html">集合</a></li>
<li class="toctree-l1"><a class="reference internal" href="Collection.html#id9">简单(常用)数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="Flink%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86.html">Flink基础配置与基础原理</a></li>
<li class="toctree-l1"><a class="reference internal" href="Hbase.html">Hbase</a></li>
<li class="toctree-l1"><a class="reference internal" href="Hive%20SQL50%E9%A2%98%E8%AE%B0%E5%BD%95.html">Hive SQL50题记录</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO%E6%B5%81.html"><code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">Stream</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="JDBC.html">JDBC</a></li>
<li class="toctree-l1"><a class="reference internal" href="Java%20Cookbook.html">JAVA Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="Java_Maven.html">Maven</a></li>
<li class="toctree-l1"><a class="reference internal" href="Java_OOP.html">面向对象是基于面向过程的编程思想</a></li>
<li class="toctree-l1"><a class="reference internal" href="Java_OOP.html#id2">特征</a></li>
<li class="toctree-l1"><a class="reference internal" href="Java_OOP.html#java-java">Java中最基础的单位是类，类是Java中最基础的单位</a></li>
<li class="toctree-l1"><a class="reference internal" href="Java%E4%B8%ADSocket%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E8%87%B3%E6%9C%8D%E5%8A%A1%E7%AB%AF.html">使用Java在服务端和客户端之间传送文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Kafka.html">Kafka</a></li>
<li class="toctree-l1"><a class="reference internal" href="MySQL%2050%E9%A2%98%E8%AE%B0%E5%BD%95.html">MySQL 50题记录</a></li>
<li class="toctree-l1"><a class="reference internal" href="MySQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.html">MySQL语句执行顺序</a></li>
<li class="toctree-l1"><a class="reference internal" href="Redis.html">Redis</a></li>
<li class="toctree-l1"><a class="reference internal" href="SQL%20JOINS.html">SQL JOINS</a></li>
<li class="toctree-l1"><a class="reference internal" href="SimpleDataStruct.html">简单(常用)数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="Socket.html">Socket</a></li>
<li class="toctree-l1"><a class="reference internal" href="Sqoop%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">Sqoop</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5.html">可能有用的学习链接</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5.html#hive-orc">Hive - ORC 文件存储格式</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">多线程</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%95%B0%E4%BB%93.html">大数据平台环境与数仓</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%A2%B3%E7%90%86.html">常用软件梳理</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%8B%89%E9%93%BE%E8%A1%A8.html">SCD</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%8B%89%E9%93%BE%E8%A1%A8.html#id2">拉链表</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8EHive.html">数据仓库</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8EHive.html#hive">Hive</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C.html">数据倾斜</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html">生产者消费者模型问题</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">JavaSE_Day08</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">面向对象知识点梳理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">类</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">封装</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">构造方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">继承</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thissuper">this和super</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">多态</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">接口</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id9">面向对象</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id10">包</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">访问修饰符</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#api">常用API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#object">Object类</a></li>
<li class="toctree-l2"><a class="reference internal" href="#string">String类</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB.html">Java OOP防脱发指南</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">roohom's notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>JavaSE_Day08</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/blogs/面向对象梳理.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="javase-day08">
<h1>JavaSE_Day08<a class="headerlink" href="#javase-day08" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>面向对象知识点梳理<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<div class="section" id="id2">
<h3>类<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>在java语言中，是使用类进行编写java程序</p></li>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">类名</span><span class="p">{</span>
    <span class="c1">//书写java代码</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>在类中可以书写的内容有哪些？</p>
<ul class="simple">
<li><p>变量</p></li>
<li><p>方法</p></li>
</ul>
</li>
<li><p>在java语言中，类除了是用来定义所书写的程序外，类的另一个作用：自定义类型</p></li>
</ul>
</div>
<div class="section" id="id3">
<h3>对象<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>当书写完自定义类后，需要对类进行初始化（数据类型  变量=初始化）</p></li>
<li><p>怎么对类进行初始化（初始化的动作，底层：开辟堆内存空间）</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span>类名  对象名 =  new  类名();

类名 ：  数据类型
对象名  ：  变量名
new  ：  告知JVM要开辟堆空间
类名()  ：  告知JVM要开辟空间的大小 （ 类中所书写的所有内容[变量]，进行换算，然后开辟空间 ）
           自动调用构造方法
</pre></div>
</div>
</li>
<li><p><img alt="avatar" src="../_images/classInit.png" /></p></li>
</ul>
</li>
</ul>
<p>小结 ：
类在程序中可以干什么？</p>
<ul class="simple">
<li><p>java的书写的程序内容都是类为单位</p>
<ul>
<li><p>类中书写的内容：变量、方法</p></li>
</ul>
</li>
<li><p>java中的类：  数据类型  （JVM基于这个数据类型，开辟堆空间）</p>
<ul>
<li><p>java语言提供的</p></li>
<li><p>程序员自己定义的（自定义类）</p></li>
</ul>
</li>
</ul>
<p>类中书写的内容，想要使用，怎么办?</p>
<ul class="simple">
<li><p>需要对类进行初始化（JVM在堆中开辟一个空间）</p></li>
<li><p>初始化代码： 类名  对象名 = new  类名()</p></li>
</ul>
</div>
<div class="section" id="id4">
<h3>封装<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>在java语言中，在类中书写程序代码（变量、方法）</p>
<ul>
<li><p>把变量、方法封装到类中</p></li>
</ul>
</li>
<li><p>在java语言中，封装的两种代码体现：</p>
<ul>
<li><p>方法 ， 封装的是一段代码块（所封装的代码块通常是用来解决一个问题的【功能】）</p></li>
<li><p>类 ， 封装的是变量和方法</p>
<ul>
<li><p>变量，成员变量（实例变量）</p>
<ul>
<li><p>为什么叫成员？</p>
<ul>
<li><p>类需要创建对象，而通过“对象.变量”的方式去访问，称为：成员变量</p></li>
</ul>
</li>
</ul>
</li>
<li><p>方法，成员方法</p></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>// 类 
class Student{
    int age;
    
}
//在使用Student -&gt; age变量
Student stu = new Student();
stu.age = -10; //赋值为非法数据（影响了程序安全性）
//以上给age赋的值为非法数据

解决方案1：  
    定义一个变量，接收 -10
    判断变量是否合法，合法：再赋值给stu.age
    int a = -10;
    if( a &gt;= 0 ){
        stu.age = a;
    }
解决方案2： 在Studetn类中 
    第1步：不让外部直接使用age变量 （使用java中的关键字：private ）
    第2步：让外部间接把值给到一个方法，在方法中判断值是否合法
          合法： 把合法值， 赋值给 age变量

    
 java语言为了保证程序的安全性，提供了一些访问权限： 让程序中的代码使用添加了权限
 public     
 private    
    
    
    class Student{
        private int age;// 私有的变量（只能在Student类中使用age）
        
        public void setAge(int age){
             // age = age;//局部变量 = 局部变量
              //就近原则：方法中的局部变量会优先使用
             //在java中，区分局部变量和成员变量，使用：this关键字
             
             if(age&gt;=0){
                  this.age = age;
             }else{
               // 异常 
               // 日志  
             }
         }
        
        public int getAge(){
            return this.age;
        }
    } 

    Student stu = new Student();
    stu.age = -10; //不能赋值（编译：报错）
    
    //赋值合法数据：
    stu.age = 10;// 编译：报错
    stu.setAge(10);
    stu.setAge(-10);//传递的是一个非法数据

    System.out.println(&quot;年龄：&quot;+ stu.getAge() );
</pre></div>
</div>
<p>问题：想要给类中书写变量，进行赋值操作，怎么实现？</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>class Student{
    private String name;
    private int age;
    //新增变量
    private String gender;
    private String phone;
    private String stuId;
    private double height;
    .....
        
    
    public void setName(String name){
        this.name = name;
    }
    。。。。
}
//对类进行初始化
Student stu = new Student();
stu.setName(&quot;测试&quot;);
stu.setAge(10);

//当类中书写的成员变量过多时，需要使用大量的setXxx()方法，给类中的变量赋值

另一个斛决方案： java中的构造方法    
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>构造方法<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>什么是构造方法？</p>
<p>1、和类名相同</p>
<p>2、没有返回值类型（不需要书写void关键字）</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>class Student{
     private String name;
     private int age;
     private String gender;
     private String phone;
     
    //构造方法
     public Student(){ //空参构造方法
         
     }
     
     public Student(String name,int age,...){
         //考虑到非法数据问题
         if( age &gt;= 0 ) {
             this.age = age;
         }else{
             
         }
         
          this.name=name;
          ...
              
         //开发中有不少这样写：   
           this.setAge(age);
           this.setPhone(phone);
     }  
    
    //给私有的age变量赋值
    public void setAge(int age){
          
             if(age&gt;=0){
                  this.age = age;
             }else{
               // 异常 
               // 日志  
             }
    } 
 }

构造方法对于书写程序的作用： 可以对类中的私有成员变量进行赋值
    
1、当类中有私有成员时，对类中的私有成员进行赋值操作：setXxx()
2、当类中有私有成员时，使用类的有参构造方法，对类中的私有成员进行赋值操作
    私有成员变量，只有在本类中使用（构造方法也属于本类）
</pre></div>
</div>
<p>小结：</p>
<p>针对类中的私有成员变量，有两种赋值方式：</p>
<p>1、public void setXxx(数据类型 参数)</p>
<p>2、类中的有参构造方法</p>
<blockquote>
<div><p>注意：构造方法不是由书写的程序调用的，而是由JVM自动调用</p>
<p>什么时候调用构造方法？</p>
<p>在对类进行初始化操作时： 类名  对象名 = new 类名(); //在执行当前行代码时，自动调用构造方法</p>
</div></blockquote>
<p>类：自定义类型（数据类型）</p>
<p>对象：对类进行初始化。 只有类初始化后，才可以访问类中的成员变量、成员方法</p>
<p>当变量、方法书写在类中时，就相当于把变量和方法进行了封装</p>
<p>为了程序中数据的安全性考虑，建议：把成员变量私有化</p>
<p>私有化的成员变量带来一个问题：外部程序无法访问</p>
<p>解决方案1： 提供相应的getter（获取私有成员变量的值）、setter（对私有成员变量赋值）</p>
<p>解决方案2： 使用类中的有参构造方法 （对私有成员变量赋值）</p>
</div>
<div class="section" id="id6">
<h3>继承<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>学生管理系统： 学生、老师
类：老师类
类：学生类
//学生类
class Student(){
    private String name;
    private int stuId;
    private int age;
    
    ....
        
    public void study(){
        ...
    }    
}
//老师类
class Teacher{
    private String name;
    private int teaId;
    private int age;
    
    ....
        
    public void teach(){
        ...
    }    
}
通过观察，Teacher类和Student类，中有不少相同的代码。
需求1：在Teacher类和Studetn类中，新增属性：教室
//学生类
class Student(){
    private String name;
    private int stuId;
    private int age;
    
    //新增
    private String classRoom;
    
    ....
        
    public void study(){
        ...
    }    
}
//老师类
class Teacher{
    private String name;
    private int teaId;
    private int age;
    
    //新增
    private String classRoom;
    
    ....
        
    public void teach(){
        ...
    }    
}
需求2：系统升级了，  原的学生学号和老师学号，int类型存储不下了，需要扩展类型： long 或 String
再对Student类和Teacher类进行改造
    

通过刚才两个需求，发现：每次都要修改多个类中的代码（程序的修改过多）
有没有简单一些方案呢？
答： 继承    
</pre></div>
</div>
<blockquote>
<div><p>要实现继承需要什么?</p>
<p>1、要定义一个父类</p>
<p>2、要定义一个子类，子类要继承父类</p>
<p>​     继承的关键字： extends</p>
</div></blockquote>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>//定义一个父类
class Person{
    private String name;
    private int teaId;
    private int age;
    ...
}
//定义一个子类
class Student extends Person{
         
    public void study(){
        ...
    }   
}
//定义一个子类
class Teacher extends Person{
    public void teach(){
        ...
    }  
}

继承的特点：
1、子类在继承父类后，可以直接使用父类中的非私有成员方法、成员变量
 
    
需求1：在Teacher类和Studetn类中，新增属性：教室 
解决方案：只需要在Person类中，添加：教室   （只修改一处代码）
class Person{
    private String name;
    private int teaId;
    private int age;
    ...
        
    //新增
    private String classRoom;    
}    
    
需求2：系统升级了，  原的学生学号和老师学号，int类型存储不下了，需要扩展类型： long 或 String
解决方案：只需要修改Person类中的代码。 int    -&gt;&lt;  long   （只修改一个类中的代码）
class Person{
    private String name;
    private long teaId;
    private int age;
    ...
        
    //新增
    private String classRoom;    
}        
</pre></div>
</div>
<p>继承的特点：
1、子类在继承父类后，可以直接使用父类中的非私有成员方法、成员变量</p>
<p>2、子类只能继承一个父类（单一继承）</p>
<p>3、子类继承一个父类，父类再继承一个爷爷类，爷爷类再继承… (多层次继承 )</p>
<ul class="simple">
<li><p>子类除了可以使用父类中的非私有成员外，还可以使用爷爷类中的非私有成员</p></li>
</ul>
<p>继承的好处：提供程序中代码的复用性</p>
<blockquote>
<div><p>继承中构造方法的原理：</p>
<p>子类在初始化对象时，为了确保子类可以正常访问父类中的成员，需要先对父类进行初始化</p>
<p>子类的构造方法中，会先调用父类的构造方法</p>
<p>示例：</p>
<p>class Person{</p>
<p>public Person(){</p>
<p>}</p>
<p>}</p>
<p>class Student extends Person{</p>
<p>public Student(){</p>
<p>​        //第一行代码： super()  //调用父类中的空参构造方法  （JVM自动添加）</p>
<p>}</p>
<p>}</p>
<p>【注意】：当父类中的没有空参构造方法时，子类的构造方法中必须书写：super(参数)</p>
</div></blockquote>
</div>
<div class="section" id="thissuper">
<h3>this和super<a class="headerlink" href="#thissuper" title="永久链接至标题">¶</a></h3>
<p>this ： 代表当前对象</p>
<p>super： 代表父类对象</p>
<p>使用方式：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//成员变量</span>
<span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="p">;</span><span class="c1">//访问本类中的成员变量</span>
<span class="kd">super</span><span class="p">.</span><span class="na">name</span><span class="p">;</span><span class="c1">//访问父类中的成员方法</span>

<span class="c1">//成员方法</span>
<span class="k">this</span><span class="p">.</span><span class="na">method</span><span class="p">();</span><span class="c1">//访问本类中的成员方法</span>
<span class="kd">super</span><span class="p">.</span><span class="na">method</span><span class="p">();</span><span class="c1">//访问父类中的成员方法</span>

<span class="c1">//构造方法</span>
<span class="k">this</span><span class="p">();</span>   <span class="k">this</span><span class="p">(</span><span class="n">参数</span><span class="p">);</span>  <span class="c1">//访问本类中的构造方法</span>
<span class="kd">super</span><span class="p">();</span>   <span class="kd">super</span><span class="p">(</span><span class="n">参数</span><span class="p">);</span> <span class="c1">//访问父类中的构造方法</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>多态<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>//父类
abstract class Person{
    private String name;
    private int age;
    
    ....
    
    //通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）
    //抽象方法： 只定义没有方法体
    public abstract void eat();
}

class Student extends Person{
    //子类在继承了抽象类后，必须重写抽象方法（java语法规定）
    public void eat(){
      System.out.println(&quot;去校区食堂吃饭...&quot;);
    }
} 
class Teacher extends Person{
    //子类在继承了抽象类后，必须重写抽象方法（java语法规定）
    public void eat(){
      System.out.println(&quot;去校外吃饭...&quot;);
    }
}

 class Test{
     public static void main(String[] args){
         //创建学生对象
         Student stu = new Student();
       
         method1( stu  , &quot;zs&quot; , 20  ,   .....)
         
         //创建老师对象
         Teacher tea = new Teacher();
          
         method2(  tea ,&quot;ls&quot; ,33 , ...... )
         
     }  
     
     
     
     //大在书写程序时：当发现有重复的代码，建议都进行抽取封装：方法、类  （复用性）
     
      public static void method1( Student stu, String name , int age , ... ){
         stu.setName( name  );//因为Student继承了Person，可以使用父类中的非私有成员
         stu.setAge(  age  );
         ....
         stu.eat();  
      }
     
      public static void metho2 ( Teacher  tea , String name , int age , ...  ){
         tea.setName(  name   );
         tea.setAge(  age  );
         ....
         tea.eat(); 
      }
     
     //添加就业班
     
     //观察以上两个方法中的代码：除了对象名不同，其它都一样   (99%都是重复代码)
     针对代码，再次精进：
     
      public void method(  ?   , String name , int age , ...){
     
         ?.setName(  name   );
         ?.setAge(  age  );
         
         ....
         ?.eat();  
      }  
     
     ? 有两个类型：  Student 、 	Teacher
     Student类型和Teacher类型有什么相同？
     继承的父类是同一个    
     
     java语言提供了一种方案：多态
     多态的使用:
     1、要有继承关系
     2、子类要重写父类中的方法
     3、 父类的引用指向子类对象
         父类  父引用  =  new  子类();
     
     
     Person p1 = new Student();
     p1.setName(...)
     p1.eat()//调用的是对象中的eat方法
         
     Person p2 = new Teacher();
     p2.setName(....)
     p2.eat();
     
     
    
     
     
      public static void method(  Person p  ,  String name , int age , ...  ){
          
         p.setName(  name   );
         p.setAge(  age  );
         
         ....
         p.eat();  
      }
     
     
     
     Student stu = new Student();
     Person p = stu ; //多态
     
     method( stu ,&quot;ls&quot; , 20 ,....);
     
     
     Teacher tea = new Teacher();
       method( tea   );
     
         
 }
</pre></div>
</div>
<p><img alt="avatar" src="../_images/multiState.png" /></p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//父类</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    
    <span class="p">....</span>
    
    <span class="c1">//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）</span>
    <span class="c1">//抽象方法： 只定义没有方法体</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校区食堂吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span> 
<span class="kd">class</span> <span class="nc">Teacher</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校外吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>



     
     
<span class="c1">//需求升学：老师需要划分为基础班老师、就业班老师</span>
<span class="c1">//父类</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    
    <span class="p">....</span>
    
    <span class="c1">//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）</span>
    <span class="c1">//抽象方法： 只定义没有方法体</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校区食堂吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span> 
     
<span class="c1">//基础班老师    </span>
<span class="kd">class</span> <span class="nc">BasicTeacher</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;吃外卖...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>     
<span class="c1">//就业班老师    </span>
<span class="kd">class</span> <span class="nc">WorkTeacher</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="c1">//子类在继承了抽象类后，必须重写抽象方法（java语法规定）</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
      <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;去校外吃饭...&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>      
     

 <span class="kd">class</span> <span class="nc">Test</span><span class="p">{</span>
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">){</span>
         <span class="c1">//创建学生对象</span>
         <span class="n">Student</span> <span class="n">stu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">();</span>
         
      
         <span class="c1">//创建基础老师对象</span>
         <span class="n">BasicTeacher</span> <span class="n">tea</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BasicTeacher</span><span class="p">();</span>
         
         <span class="c1">//创建就业班老师对象</span>
         <span class="n">WorkTeacher</span> <span class="n">tea2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WorkTeacher</span><span class="p">();</span>
        
      
         <span class="n">method</span><span class="p">(</span>  <span class="n">stu</span> <span class="p">,</span> <span class="s">&quot;zs&quot;</span> <span class="p">,</span> <span class="mi">20</span>  <span class="p">)</span>
         <span class="n">method</span><span class="p">(</span>  <span class="n">tea</span> <span class="p">,</span> <span class="s">&quot;ls&quot;</span> <span class="p">,</span> <span class="mi">33</span>  <span class="p">)</span>  
             
         <span class="n">method</span><span class="p">(</span>  <span class="n">tea2</span>  <span class="p">,</span> <span class="s">&quot;ja&quot;</span>  <span class="mi">30</span>  <span class="p">)</span>    
         
     <span class="p">}</span>  
     
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="p">(</span>  <span class="n">Person</span>  <span class="n">p</span> <span class="p">,</span>  <span class="n">String</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">){</span>
         <span class="n">p</span><span class="p">.</span><span class="na">setName</span><span class="p">(</span> <span class="n">name</span> <span class="p">)</span>
         <span class="n">p</span><span class="p">.</span><span class="na">setAge</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
         <span class="p">...</span>
         
         <span class="n">p</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>    
      <span class="p">}</span>
 <span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p>在使用多态时，存在 一个问题：父引用无法使用子类中特有的成员</p>
<p>解决方案： 使用向下转型 （强制类型转换）</p>
<p>格式：子类  子类对象 = (子类) 父引用</p>
<p>当在进行强制类型转换时，如果父引用指向的对象类型 和 要转换的类型不匹配，就会发生：错误</p>
<p>父引用指向的对象类型 ：  Person p = new Student();  //类型：Student</p>
<p>要转换的类型：  Teacher</p>
<p>错误代码：  Teacher tea  = (Teacher ) p;//类型转换错误</p>
<p>通常在进行向下转型时，会先进行判断：</p>
<p>if( p  instanceo  Teacher){</p>
<p>Teacher tea  = (Teacher ) p;</p>
<p>}</p>
<p>父引用  instanceof  子类类型    ：  判断父引用指向的对象类型 是否为 子类类型</p>
</div></blockquote>
<p>抽象类</p>
<ul>
<li><p>为什么有抽象类？</p>
<ul class="simple">
<li><p>当程序中书写的方法只有声明，没有方法体代码实现，该需要修饰为：abstract</p></li>
<li><p>抽象方法必须存在于抽象类中</p></li>
</ul>
</li>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="c1">//抽象方法</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>抽象类的特点：</p>
<ul class="simple">
<li><p>不能实例化（ 不能创建对象。 只能通过子类来创建对象[多态的方式] ）</p></li>
<li><p>抽象类和普通类，除了不能实例化、多了一个抽象方法外，其他和普通类都一样</p>
<ul>
<li><p>抽象类中可以书写的内容：抽象方法、构造方法、成员变量、成员方法</p></li>
<li><p>抽象类中的构造方法的作用：为了保证子类对象创建成功</p></li>
</ul>
</li>
<li><p>抽象类通常都是父类</p></li>
<li><p>抽象类中的抽象方法，子类必须重写</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id8">
<h3>接口<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>接口比类好的地方：可以多实现

接口在java中怎么使用：
1、定义一个接口
2、定义一个子类，子类实现接口，子类中并重写接口中的抽象方法
3、接口要创建对象，只使用多态的形式：  接口  父引用 = new  子类()

    
//定义接口
interface InterA{
    //接口中可书写内容是固定的
    常量、抽象方法、静态方法、默认方法
        
    public static final int NUM=10;//常量
    public abstract void method();//抽象方法
    public static void method2(){
        
    }
    public default void method3{
        
    }
}
//定义实现接口的类
class MyInter implements InterA{
    //重写抽象方法
}
//使用接口：
InterA inter = new MyInter();
</pre></div>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>abstract classs Person{
    String name;
    int age ;
    
   abstract  void eat();
}
class BasicStudent extends Person{
    
    public void study(){
        
    }
}
class WorkStudent extends Person implements InterA{
    public void study(){
        
    }
    //特有的功能
    public void mianshi(){
        
    }
}

class BasicTeacher extends Person{
    public void teach(){
        
    }
    
}
class WorkerTeacher extends Person implements InterA{
     public void teach(){
        
    }
     //特有的功能
    public void mianshi(){
        
    }
}

interface InterA{
    public void mianshi();
}

需求：学生都有学习方法、老师都讲课方法
    就业班学生、就业班老师都具有：面试能力
    
BasicStudent bs = new BasicStudent();
WorkTeacher tea = new WorkTeacher();

接口：
    1、当有部分类中的功能是相同时，可以把这部分相同的功能，抽取出来，封装到：接口

 
要执行就业班老师和就业班学生的：面试功能
WorkTeacher tea = new WorkTeacher();
WorkStudenet stu = new WorkStudent();
tea.mianshi();
stu.mianshi();


method( tea );
method(  stu )


public void method( InterA inter ){
    inter.mianshi()
}
</pre></div>
</div>
<p>在企业开发中，大量使用接口。</p>
<blockquote>
<div><p>为什么？</p>
<p>通常在开发前期，会针对开发中的功能进行制定（需求分析）</p>
<p>前期：制定功能（没有功能代码）</p>
<p>​           使用抽象方法</p>
<p>问题：抽象方法是定义哪里？  抽象类  or 接口？</p>
<p>答案： 接口  （接口可以多实现）</p>
<p>程序开发：接口</p>
<p>public interface 接口A｛</p>
<p>//功能1：</p>
<p>​                public  boolean  login(String name,Strng passwd);</p>
<p>//功能2：</p>
<p>​                 public  boolean  changePasswd(String name , String oldPasswd);</p>
<p>}</p>
<p>public interface 接口B｛</p>
<p>…..</p>
<p>｝</p>
</div></blockquote>
<p>进入到开发阶段：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>//程序员01号
class UserImpl implements IUser｛
   //重写抽象方法 
    具体方法中的功能代码
｝
class OrderImpl implements  IOrder{
    
}
class ManagerImpl  implements IManager{
    
}
    
=======================================================    
    
    
//程序员02号    
class 类{
    
    public void method(){
        
        //让用户先登录
        IUser user = new UserImpl();//多态  接口 
        user.login(&quot;&quot;,&quot;&quot;)
        
    }
}    
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id9">
<h1>面向对象<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h1>
<div class="section" id="id10">
<h2>包<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>在学习java基础时，使用过Scanner。 要使用Scanner需要导入：import java.util.Scanner</p>
<p>包是什么？</p>
<ul class="simple">
<li><p>文件夹</p>
<ul>
<li><p>可以帮我们管理文件</p></li>
</ul>
</li>
</ul>
<p>包能做什么？</p>
<ul class="simple">
<li><p>在开发中，程序员会书写很多的类，这些类有一些可能会出现重名</p></li>
<li><p>在开发中，所开发的项目中，会包含不同功能模块：商品、订单、用户、….</p>
<ul>
<li><p>针对不同的功能模块，书写不同的java程序</p></li>
</ul>
</li>
<li><p>包的作用：可以帮我们管理.java文件</p>
<ul>
<li><p>避免重名</p></li>
<li><p>实现不同功能的类，可以存放在不同的功能模块下</p></li>
</ul>
</li>
</ul>
<p>怎么使用包？</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>创建包：package
    把不现的.java文件存放在不同的包下
    
导入包：import    
    当需要使用别人开发好的功能时，需要先找到功能所属的类，然后使用import导入这个类
    创建类对象，使用对象.功能()   
</pre></div>
</div>
<p>package使用注意事项：</p>
<p>1、package必须书写在java程序的首行</p>
<p>2、一个.java文件夹中，只能书写 一个package</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">com.itheima</span><span class="p">;</span>  <span class="c1">//只能有一个package</span>
<span class="c1">//package com.itcast;//报错</span>
    

<span class="kd">class</span> <span class="nc">Itcast</span><span class="p">{</span>
    
<span class="p">}</span>    
</pre></div>
</div>
<p>包的命名规则：</p>
<p>1、全部小写字母</p>
<p>2、包名通常使用域名，倒着写的方式（企业中的标准）</p>
<p>3、通常创建包名，都是有多个包，包之间使用.连接</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">com.itheima.hw.demo1</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
<p>在书写程序时，需要引用别人写好的类中功能，需要：导包</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">com.itheima</span><span class="p">;</span><span class="c1">// Test类归属的包</span>

<span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="p">;</span><span class="c1">//导包</span>

<span class="kd">class</span> <span class="nc">Test</span><span class="p">{</span>
    <span class="n">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">in</span><span class="p">);</span><span class="c1">///要使用别人写的功能，要导入</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在书写 程序时，有两种导入包的方式：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>第一种：(不推荐)
    java.util.Scanner  sc = new java.util.Scanner(System.in);//书写类名时直接把包导入

    java.util.Scanner  sc2 = new java.util.Scanner(System.in);

    java.util.Scanner  sc3 = new java.util.Scanner(System.in);

第二种：
    import java.util.Scanner;

    Scanner sc = new Scanner(System.in);

    Scanner sc2 = new Scanner(System.in);
 
    Scanner sc3 = new Scanner(System.in);
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>访问修饰符<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<p>在java中为了程序的安全性，java语言提供了4种用来访问成员的权限</p>
<p>1、public</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span><span class="p">{</span>
    <span class="c1">//公开的</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">study</span><span class="p">(){</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>2、private</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span><span class="p">{</span>
   <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span><span class="c1">//私有的。只能本类使用</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>3、默认       什么都不书写</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span><span class="p">{</span>
    <span class="n">String</span> <span class="n">name</span><span class="p">;</span><span class="c1">//默认的访问修饰符</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>4、protected</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">pubilc</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span><span class="p">{</span>
    <span class="kd">protected</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span><span class="c1">//受保护的（子类专用）</span>
<span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>访问修饰符号的访问范围</strong></p>
</div></blockquote>
</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>修饰符号 (从小到大排列)</th>
<th>本类</th>
<th>同一个包下的类(非子类)</th>
<th>同一个包下的子类</th>
<th>不同包下的类（非子类）</th>
<th>不同包下的子类</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td><strong>YES</strong></td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>默认</td>
<td><strong>YES</strong></td>
<td><strong>YES</strong></td>
<td><strong>YES</strong></td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>protected</td>
<td><strong>YES</strong></td>
<td>NO</td>
<td><strong>YES</strong></td>
<td>NO</td>
<td><strong>YES</strong></td>
</tr>
<tr>
<td>public</td>
<td><strong>YES</strong></td>
<td><strong>YES</strong></td>
<td><strong>YES</strong></td>
<td><strong>YES</strong></td>
<td><strong>YES</strong></td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="api">
<h1>常用API<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h1>
<div class="section" id="object">
<h2>Object类<a class="headerlink" href="#object" title="永久链接至标题">¶</a></h2>
<p>Object类的基本认知：</p>
<p>1、java.lang.Object</p>
<p>2、Obejct类是java语言中的鼻祖类（最顶层的父类）</p>
<p>3、java中程序中所书写的类以及所使用的类，都要继承Object</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//父类</span>
<span class="kd">class</span> <span class="nc">Father</span><span class="p">{</span><span class="c1">//书写时没有书写继承 JVM自动会添加：class Father extends Object</span>

<span class="p">}</span>
<span class="c1">//子类 </span>
<span class="kd">class</span> <span class="nc">Child</span> <span class="kd">extends</span> <span class="n">Father</span><span class="p">{</span>

<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>可以使用Object类中的成员方法(功能)</p></li>
</ul>
<p>Object类中的成员方法 ：</p>
<ul>
<li><p>String   toString()</p>
<ul class="simple">
<li><p>功能：返回字符串格式的对象</p></li>
</ul>
</li>
<li><p>boolean  equals(Object  obj)</p>
<ul>
<li><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">Student</span> <span class="n">stu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">();</span>

<span class="n">equals</span><span class="p">(</span>  <span class="n">stu</span>  <span class="p">)</span>   <span class="c1">//   Object obj = stu;</span>
</pre></div>
</div>
</li>
<li><p>功能：比较两个对象是否相等</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="string">
<h2>String类<a class="headerlink" href="#string" title="永久链接至标题">¶</a></h2>
<p>之前一直在使用：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Student</span><span class="p">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>String到底是什么 东西？ 它是一种数据类型呢？还是一个类呢？</p>
<p>String是一个类。不属于java的基本数据类型，属于引用类型</p>
<p>在java语言中，只要书写了<code class="docutils literal notranslate"><span class="pre">&quot;....&quot;</span></code>,默认就是一个字符串对象：String类的对象</p>
<p>简单理解：在java中只要被英文的双引号包含的内容，默认就是一个String对象</p>
<p>String类的特点：</p>
<p>1、被英文双引号包含的内容，都是一个String类的实例</p>
<p>2、String中存储的字符串，不能被修改（不能对原值进行修改）</p>
<p>String类中的常用方法 ：</p>
<ul class="simple">
<li><p>boolean  equals(Object obj)  :     String类重写了Object类中equals方法。</p>
<ul>
<li><p>String类中的equals方法 ，功能：  比较两个字符串的内容是否相等，区分大小字母</p></li>
<li><p>在java语言中：</p>
<ul>
<li><p>比较字符串的地址，使用 ： ==</p></li>
<li><p>比较字符串内容，使用： equals() 方法</p></li>
</ul>
</li>
</ul>
</li>
<li><p>boolean  equalsIgnoreCase(String  str)  ：   比较两个字符串是否相等，忽略大小写</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB.html" class="btn btn-neutral float-right" title="Java OOP防脱发指南" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html" class="btn btn-neutral float-left" title="生产者消费者模型问题" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 版权所有 2020, roohom

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>